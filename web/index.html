<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <title>SCAI Lab Simulation Control Panel</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        /* Custom scrollbar styles (Tailwind doesn't style these by default) */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #111827; /* gray-900 */
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #374151; /* gray-700 */
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #4b5563; /* gray-600 */
        }
        
        /* Chart.js responsiveness */
        .chart-container {
            position: relative;
            height: 200px;
            width: 100%;
        }

        /* Terminal-specific line styling */
        .terminal-line { margin: 2px 0; word-wrap: break-word; }
        .terminal-timestamp { color: #6b7280; margin-right: 10px; }
        .terminal-prompt { color: #9ca3af; margin-right: 6px; }

        /* Log-specific line styling */
        .log-line { margin: 1px 0; word-wrap: break-word; font-size: 11px; }
        .log-timestamp { color: #6b7280; margin-right: 8px; }
        .log-level-info { color: #60a5fa; }
        .log-level-warn { color: #facc15; }
        .log-level-error { color: #f87171; }
        .log-level-debug { color: #a78bfa; }
    </style>
</head>

<body class="font-sans m-0 bg-gray-900 text-gray-200 flex h-screen overflow-hidden">

    <aside class="w-72 bg-gray-950 flex-shrink-0 p-4 border-r border-gray-800 overflow-y-auto custom-scrollbar">
        <h2 class="text-xl font-semibold text-white mb-4">Configuration</h2>
        <div class="space-y-6">
            <div>
                <label class="block text-sm font-medium text-gray-400 mb-2">Simulation Controls</label>
                <div class="space-y-2">
                    <button id="runButton" class="w-full bg-blue-600 text-white py-2 px-4 rounded-md font-medium hover:bg-blue-500 disabled:bg-gray-700 disabled:text-gray-400 disabled:cursor-not-allowed">
                        Run Simulation
                    </button>
                    <button id="refreshButton" class="w-full bg-gray-700 text-gray-200 border border-gray-600 py-2 px-4 rounded-md hover:bg-gray-600">
                        Refresh Image
                    </button>
                </div>
            </div>

            <div>
                <label for="sim-model" class="block text-sm font-medium text-gray-400">Simulation Model</label>
                <select id="sim-model" class_name="mt-1 block w-full bg-gray-800 border border-gray-700 rounded-md shadow-sm py-2 px-3 text-gray-200 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    <option>HomeRobotSim (Default)</option>
                    <option>Habitat 2.0</option>
                    <option>iGibson</option>
                </select>
            </div>
            
            <div>
                <label for="scene-select" class="block text-sm font-medium text-gray-400">Scene</label>
                <select id="scene-select" class_name="mt-1 block w-full bg-gray-800 border border-gray-700 rounded-md shadow-sm py-2 px-3 text-gray-200 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    <option>Apartment (Default)</option>
                    <option>Office</option>
                    <option>Kitchen</option>
                </select>
            </div>

            <div>
                <label for="max-steps" class="block text-sm font-medium text-gray-400">Max Steps</label>
                <input type="number" id="max-steps" value="1000" class="mt-1 block w-full bg-gray-800 border border-gray-700 rounded-md shadow-sm py-2 px-3 text-gray-200 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" />
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-400 mb-2">Terminal Controls</label>
                <button id="clearTerminalButton" class="w-full bg-gray-700 text-gray-200 border border-gray-600 py-2 px-4 rounded-md hover:bg-gray-600">
                    Clear Terminal
                </button>
            </div>
            
            <div>
                <label class="block text-sm font-medium text-gray-400 mb-2">Log Controls</label>
                <button id="clearLogsButton" class="w-full bg-gray-700 text-gray-200 border border-gray-600 py-2 px-4 rounded-md hover:bg-gray-600">
                    Clear System Logs
                </button>
            </div>
        </div>
    </aside>

    <main class="flex-1 flex flex-col overflow-hidden">
        
        <header class="bg-gray-950 border-b border-gray-800 p-4 flex-shrink-0">
            <div class="flex justify-between items-center">
                <h1 class="text-xl text-gray-200 font-semibold">SCAI Lab Simulation Control Panel</h1>
                <div id="status" class="italic text-gray-400 text-center min-h-[22px]">
                    Status: Idle
                </div>
            </div>
        </header>

        <div class="flex-1 p-4 grid grid-cols-1 lg:grid-cols-5 gap-4 overflow-y-auto custom-scrollbar">
            
            <div class="lg:col-span-3 flex flex-col space-y-4">
                <div class="flex flex-col bg-gray-800 rounded-md border border-gray-700 flex-1">
                    <h3 class="panel-title text-gray-300 text-base mb-0 text-center border-b border-gray-700 p-3 font-medium">Live Simulation Feed</h3>
                    <div id="live-feed-container" class="flex-1 flex flex-col items-center justify-center p-4 min-h-[300px]">
                        <img id="liveFeedImage" alt="Live simulation feed will appear here..." src="" class="border border-gray-600 max-w-full max-h-full h-auto hidden" />
                        <div class="no-image text-gray-500 italic" id="noImageMessage">
                            No simulation feed available
                        </div>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-md border border-gray-700">
                    <h3 class="panel-title text-gray-300 text-base mb-0 text-center border-b border-gray-700 p-3 font-medium">Simulation Metrics</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 p-4">
                        <div class="chart-container">
                            <canvas id="cpuChart"></canvas>
                        </div>
                        <div class="chart-container">
                            <canvas id="memChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="lg:col-span-2 flex flex-col space-y-4">
                <div class="flex flex-col bg-gray-800 rounded-md border border-gray-700 flex-1">
                    <h3 class="panel-title text-gray-300 text-base mb-0 text-center border-b border-gray-700 p-3 font-medium">Terminal Console</h3>
                    <div id="terminal" class="flex-1 bg-black p-3 font-mono text-xs leading-relaxed overflow-y-auto custom-scrollbar min-h-[280px]">
                        </div>
                </div>

                <div class="flex flex-col bg-gray-800 rounded-md border border-gray-700 flex-1">
                    <h3 class="panel-title text-gray-300 text-base mb-0 text-center border-b border-gray-700 p-3 font-medium">System Logs</h3>
                    <div id="systemLogs" class="flex-1 bg-black p-3 font-mono text-xs leading-relaxed overflow-y-auto custom-scrollbar min-h-[280px]">
                        </div>
                </div>
            </div>

        </div>
    </main>
    

    <script>
        // --- DOM Element References ---
        const runButton = document.getElementById('runButton');
        const refreshButton = document.getElementById('refreshButton');
        const clearTerminalButton = document.getElementById('clearTerminalButton');
        const clearLogsButton = document.getElementById('clearLogsButton');
        const statusDiv = document.getElementById('status');
        const liveFeedImage = document.getElementById('liveFeedImage');
        const noImageMessage = document.getElementById('noImageMessage');
        const terminal = document.getElementById('terminal');
        const systemLogs = document.getElementById('systemLogs');
        
        // --- Global State ---
        let socket;
        let imagePollingInterval;
        let cpuChart, memChart;

        // --- Color Maps for Dynamic Styling ---
        const statusColorMap = {
            error: 'text-red-400 font-semibold',
            warning: 'text-yellow-400',
            info: 'text-gray-400',
            success: 'text-green-400',
            running: 'text-blue-400',
            complete: 'text-green-400',
            idle: 'text-gray-400'
        };
        
        const terminalColorMap = {
            error: 'text-red-400',
            warning: 'text-yellow-400',
            info: 'text-gray-200', // Default text
            success: 'text-green-400'
        };

        const logLevelMap = {
            'INFO': 'log-level-info',
            'WARN': 'log-level-warn',
            'ERROR': 'log-level-error',
            'DEBUG': 'log-level-debug',
        };

        // =======================================================================
        // === UTILITY FUNCTIONS =================================================
        // =======================================================================

        /**
         * Gets the current time as a HH:MM:SS string.
         * @returns {string} The formatted time.
         */
        function getCurrentTime() {
            return new Date().toTimeString().split(' ')[0];
        }

        /**
         * Sets the main status message text and color.
         * @param {string} message - The message to display.
         * @param {string} type - The status type (e.g., 'error', 'success').
         */
        function setStatus(message, type = 'info') {
            statusDiv.textContent = `Status: ${message}`;
            const allColors = Object.values(statusColorMap).join(' ').split(' ');
            statusDiv.classList.remove(...allColors);
            const newColors = (statusColorMap[type] || 'text-gray-400').split(' ');
            statusDiv.classList.add(...newColors);
        }

        /**
         * Adds a new line to the specified panel (terminal or logs).
         * @param {HTMLElement} panel - The DOM element (terminal or systemLogs).
         * @param {string} htmlContent - The inner HTML to add.
         */
        function addLineToPanel(panel, htmlContent) {
            const line = document.createElement('div');
            line.innerHTML = htmlContent;
            panel.appendChild(line);
            panel.scrollTop = panel.scrollHeight; // Auto-scroll
        }

        /**
         * Adds a formatted line to the terminal.
         * @param {string} message - The message content.
         * @param {string} type - The message type for coloring.
         */
        function addTerminalLine(message, type = 'info') {
            const colorClass = terminalColorMap[type] || 'text-gray-200';
            const html = `
                <div class="terminal-line">
                    <span class="terminal-timestamp">[${getCurrentTime()}]</span>
                    <span class="terminal-prompt">$</span>
                    <span class="${colorClass}">${message}</span>
                </div>
            `;
            addLineToPanel(terminal, html);
        }

        /**
         * Adds a formatted line to the system log panel.
         * @param {string} message - The log message.
         * @param {string} level - The log level (e.g., 'INFO', 'ERROR').
         */
        function addSystemLog(message, level = 'INFO') {
            const colorClass = logLevelMap[level] || 'log-level-info';
            const html = `
                <div class="log-line">
                    <span class="log-timestamp">[${getCurrentTime()}]</span>
                    <span class="font-medium ${colorClass}">[${level}]</span>
                    <span class="text-gray-300 ml-1">${message}</span>
                </div>
            `;
            addLineToPanel(systemLogs, html);
        }

        /**
         * Clears all content from the terminal panel.
         */
        function clearTerminal() {
            terminal.innerHTML = '';
            addTerminalLine('Terminal cleared.', 'info');
        }
        
        /**
         * Clears all content from the system logs panel.
         */
        function clearLogs() {
            systemLogs.innerHTML = '';
            addSystemLog('System logs cleared.', 'INFO');
        }

        /**
         * Updates the display of the live feed image.
         * @param {string | null} imageSrc - The base64 image data string, or null.
         */
        function updateImageDisplay(imageSrc) {
            if (imageSrc) {
                liveFeedImage.src = imageSrc;
                liveFeedImage.classList.remove('hidden');
                noImageMessage.classList.add('hidden');
            } else {
                liveFeedImage.classList.add('hidden');
                noImageMessage.classList.remove('hidden');
            }
        }

        // =======================================================================
        // === CHARTING FUNCTIONS ================================================
        // =======================================================================

        /**
         * Creates a new Chart.js instance.
         * @param {string} canvasId - The ID of the <canvas> element.
         * @param {string} label - The label for the dataset.
         * @param {string} borderColor - The line color.
         * @param {string} bgColor - The background gradient color.
         * @returns {Chart} The new Chart instance.
         */
        function createChart(canvasId, label, borderColor, bgColor) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            const gradient = ctx.createLinearGradient(0, 0, 0, 200);
            gradient.addColorStop(0, bgColor);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array(20).fill(''),
                    datasets: [{
                        label: label,
                        data: Array(20).fill(0),
                        borderColor: borderColor,
                        backgroundColor: gradient,
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.3,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: { color: '#9ca3af' },
                            grid: { color: '#374151' }
                        },
                        x: {
                            ticks: { display: false },
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { color: '#d1d5db' }
                        }
                    }
                }
            });
        }

        /**
         * Adds a new data point to a chart and shifts old data.
         * @param {Chart} chart - The Chart.js instance.
         * @param {number} newData - The new data point to add.
         */
        function updateChart(chart, newData) {
            chart.data.labels.push('');
            chart.data.labels.shift();
            chart.data.datasets[0].data.push(newData);
            chart.data.datasets[0].data.shift();
            chart.update('quiet'); // 'quiet' prevents animation
        }
        
        /**
         * Initializes both charts on page load.
         */
        function initializeCharts() {
            cpuChart = createChart('cpuChart', 'CPU Usage (%)', '#3b82f6', 'rgba(59, 130, 246, 0.3)');
            memChart = createChart('memChart', 'Memory Usage (%)', '#10b981', 'rgba(16, 185, 129, 0.3)');
            addSystemLog('Metrics charts initialized.', 'DEBUG');
        }

        // =======================================================================
        // === ASYNC & WEBSOCKET FUNCTIONS =======================================
        // =======================================================================

        /**
         * Connects to the WebSocket server and sets up event handlers.
         */
        function connectWebSocket() {
            const wsProtocol = window.location.protocol === 'https:';
            const wsUrl = `${wsProtocol ? 'wss' : 'ws'}://${window.location.host}/ws/live_feed`;
            
            console.log(`Connecting to WebSocket: ${wsUrl}`);
            socket = new WebSocket(wsUrl);

            socket.onopen = function(event) {
                console.log("WebSocket connection established.");
                addTerminalLine("WebSocket connection established.", 'success');
                addSystemLog("WebSocket connected successfully.", 'INFO');
                setStatus('WebSocket Connected. Ready to run.', 'info');
            };

            socket.onmessage = function(event) {
                handleSocketMessage(event.data);
            };

            socket.onclose = function(event) {
                console.log("WebSocket connection closed.", event);
                addTerminalLine("WebSocket connection closed.", 'warning');
                addSystemLog(`WebSocket disconnected. Code: ${event.code}`, 'WARN');
                setStatus('Disconnected. Please refresh.', 'error');
                runButton.disabled = true;
                if (imagePollingInterval) clearInterval(imagePollingInterval);
            };

            socket.onerror = function(error) {
                console.error("WebSocket error:", error);
                addTerminalLine("WebSocket connection error.", 'error');
                addSystemLog("WebSocket connection error.", 'ERROR');
                setStatus('Connection Error.', 'error');
                runButton.disabled = true;
            };
        }

        /**
         * Routes incoming WebSocket messages to the correct handler.
         * @param {string} message - The raw message data from the server.
         */
        function handleSocketMessage(message) {
            try {
                if (message.startsWith("data:image/")) {
                    // It's an image frame
                    updateImageDisplay(message);
                    
                } else if (message.startsWith("status:")) {
                    // Format: "status:type:message"
                    const [, statusType, statusMessage] = message.split(':', 3);
                    console.log(`Status Update: ${statusType} - ${statusMessage}`);
                    setStatus(`${statusType} - ${statusMessage}`, statusType);
                    addTerminalLine(`[${statusType.toUpperCase()}] ${statusMessage}`, statusType);

                    if (statusType === 'complete' || statusType === 'error') {
                        runButton.disabled = false;
                        if (imagePollingInterval) clearInterval(imagePollingInterval);
                    }
                } else if (message.startsWith("log:")) {
                    // Format: "log:LEVEL:message"
                    const [, level, logMessage] = message.split(':', 3);
                    addSystemLog(logMessage, level.toUpperCase());

                } else if (message.startsWith("metric:")) {
                    // Format: "metric:type:value"
                    const [, metricType, metricValue] = message.split(':', 3);
                    const value = parseFloat(metricValue);
                    if (metricType === 'cpu') {
                        updateChart(cpuChart, value);
                    } else if (metricType === 'mem') {
                        updateChart(memChart, value);
                    }
                } else {
                    // Fallback for unexpected messages
                    console.log("Received unhandled message:", message);
                    addSystemLog(`Unhandled message: ${message}`, 'DEBUG');
                }
            } catch (e) {
                console.error("Error handling message:", e);
                addSystemLog(`Failed to parse message: ${message}`, 'ERROR');
            }
        }

        /**
         * Fetches the single latest image from the server.
         */
        async function fetchLatestImage() {
            try {
                const response = await fetch('/latest-image');
                const data = await response.json();
                
                if (data.image) {
                    updateImageDisplay(data.image);
                    addTerminalLine(`Displaying ${data.filename} (${data.total_images} total images)`, 'info');
                } else {
                    updateImageDisplay(null);
                }
            } catch (error) {
                console.error("Failed to fetch latest image:", error);
                addTerminalLine(`Failed to fetch latest image: ${error.message}`, 'error');
                addSystemLog(`Failed to fetch latest image: ${error.message}`, 'ERROR');
            }
        }

        /**
         * Sends the request to the server to start the simulation.
         */
        async function handleRunSimulation() {
            console.log("Requesting simulation start...");
            addTerminalLine("Starting simulation...", 'info');
            addSystemLog("Simulation run requested by user.", 'INFO');
            runButton.disabled = true;
            setStatus('Requesting simulation start...', 'running');
            updateImageDisplay(null);

            try {
                const response = await fetch('/run-simulation', { method: 'POST' });
                const data = await response.json();
                console.log("Simulation start request sent:", data.message);
                addTerminalLine(`Simulation start request sent: ${data.message}`, 'success');
                addSystemLog(`Server responded: ${data.message}`, 'INFO');
                
                if (imagePollingInterval) clearInterval(imagePollingInterval);
                imagePollingInterval = setInterval(fetchLatestImage, 500);
                
                if (!socket || socket.readyState !== WebSocket.OPEN) {
                    console.log("WebSocket not open, attempting connection...");
                    addTerminalLine("WebSocket not open, attempting connection...", 'warning');
                    addSystemLog("WebSocket not open, reconnecting...", 'WARN');
                    connectWebSocket(); 
                }

            } catch (error) {
                console.error("Failed to send start simulation request:", error);
                addTerminalLine(`Failed to send start simulation request: ${error.message}`, 'error');
                addSystemLog(`Failed to start simulation: ${error.message}`, 'ERROR');
                setStatus('Error starting simulation.', 'error');
                runButton.disabled = false;
            }
        }

        // =======================================================================
        // === INITIALIZATION & EVENT LISTENERS ==================================
        // =======================================================================

        /**
         * Main function to initialize the application.
         */
        function initializeApp() {
            // Set up button listeners
            runButton.addEventListener('click', handleRunSimulation);
            refreshButton.addEventListener('click', () => {
                addTerminalLine("Manually refreshing image...", 'info');
                fetchLatestImage();
            });
            clearTerminalButton.addEventListener('click', clearTerminal);
            clearLogsButton.addEventListener('click', clearLogs);

            // Add initial lines
            addTerminalLine("Initializing system...", 'info');
            addSystemLog("Control panel UI initialized.", 'INFO');
            
            // Initialize charts
            initializeCharts();
            
            // Connect to WebSocket
            connectWebSocket();
            
            // Load the latest image on page load
            addTerminalLine("Loading latest image...", 'info');
            fetchLatestImage();

            // Mock metrics for demo
            addSystemLog("Starting mock metrics for demo. Remove in production.", 'WARN');
            setInterval(() => {
                if (!runButton.disabled) { // Only show mock data when idle
                    handleSocketMessage(`metric:cpu:${(Math.random() * 5).toFixed(1)}`);
                    handleSocketMessage(`metric:mem:${(Math.random() * 3 + 10).toFixed(1)}`);
                }
            }, 1000);
        }

        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>
</body>
</html>